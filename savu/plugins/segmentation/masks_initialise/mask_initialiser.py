# Copyright 2019 Diamond Light Source Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
.. module:: A plugin to initialise a binary mask for level sets and distance transform segmentations
   :platform: Unix
   :synopsis: A plugin to initialise a binary mask for level sets and distance transform segmentations

.. moduleauthor:: Daniil Kazantsev <scientificsoftware@diamond.ac.uk>
"""

from savu.plugins.plugin import Plugin
from savu.plugins.driver.cpu_plugin import CpuPlugin
from savu.plugins.utils import register_plugin

import numpy as np

# using Morphological snakes module from
# https://github.com/pmneila/morphsnakes
from morphsnakes import circle_level_set

@register_plugin
class MaskInitialiser(Plugin, CpuPlugin):
    """
    A plugin to initialise a binary mask for level sets and distance transform segmentations.\
    Seeds are generated by providing coordinates of three points in 3D space (start-middle-finish) \
    and connecting them with a cylinder of a certain radius. \
    Importantly the Z coordinate is given following VOLUME_XY vertical pattern

    :param init_coordinates: X0,Y0,Z0 (start) X1,Y1,Z1 (middle) and X2,Y2,Z2 (finish) coordinates of three points. Default: [10, 10, 0, 15, 15, 15, 20, 20, 20].
    :param circle_radius: The seed will be initialised with a circle of radius. Default: 5.
    :param out_datasets: The default names . Default: ['INIT_MASK'].
    """

    def __init__(self):
        super(MaskInitialiser, self).__init__("MaskInitialiser")

    def setup(self):
        in_dataset, out_dataset = self.get_datasets()
        in_pData, out_pData = self.get_plugin_datasets()
        in_pData[0].plugin_data_setup('VOLUME_YZ', 'single')
        
        out_dataset[0].create_dataset(in_dataset[0], dtype=np.uint8)
        out_pData[0].plugin_data_setup('VOLUME_YZ', 'single')
        self.full_input_shape = in_dataset[0].get_shape()
        
    def pre_process(self):
        # extract given parameters
        self.circle_radius = self.parameters['circle_radius']
        self.init_coordinates = self.parameters['init_coordinates']
        
        self.coordX0 = self.init_coordinates[0]
        self.coordY0 = self.init_coordinates[1]
        self.coordZ0 = self.init_coordinates[2]
        self.coordX1 = self.init_coordinates[3]
        self.coordY1 = self.init_coordinates[4]
        self.coordZ1 = self.init_coordinates[5]
        self.coordX2 = self.init_coordinates[6]
        self.coordY2 = self.init_coordinates[7]
        self.coordZ2 = self.init_coordinates[8]
        
        steps1 = self.coordZ1 - self.coordZ0
        self.distance1 = np.sqrt((self.coordX1 - self.coordX0)**2 + (self.coordY1 - self.coordY0)**2)
        self.d_dist1 = self.distance1/(steps1 - 1.0)
        self.d_step1 = self.d_dist1
        steps2 = self.coordZ2 - self.coordZ1
        self.distance2 = np.sqrt((self.coordX2 - self.coordX1)**2 + (self.coordY2 - self.coordY1)**2)
        self.d_dist2 = self.distance2/(steps2 - 1.0)
        self.d_step2 = self.d_dist2

    def process_frames(self, data):
        # get the index of a current frame
        index_current = self.get_plugin_in_datasets()[0].get_current_frame_idx()
        [dimX,dimY] = np.shape(data[0])
        mask = np.uint8(np.zeros(np.shape(data[0])))
        if ((index_current >= self.coordZ0) & (index_current <= self.coordZ1)):
            if ((self.coordX0 == 0) & (self.coordY0 == 0) & (self.coordX1 == 0) & (self.coordY1 == 0)):
                # create a full region mask (except the boundaries)
                bound_width=2 # outer boundary width
                mask[bound_width:dimX-bound_width, bound_width:dimY-bound_width] = 1
            else:
                self.d_step1 = (index_current - self.coordZ0)*self.d_dist1
                t = self.d_step1/self.distance1
                if (self.coordX0 == self.coordX1):
                    x_t = np.int(self.coordX0)
                else:
                    x_t1 = np.round((1.0 - t)*self.coordX0 + t*self.coordX1)
                    x_t = np.int(x_t1[0])
                if(self.coordY0 == self.coordY1):
                    y_t = np.int(self.coordY0)
                else:
                    y_t1 = np.round((1.0 - t)*self.coordY0 + t*self.coordY1)
                    y_t = np.int(y_t1[0])
                mask = np.uint8(circle_level_set(np.shape(data[0]), (y_t, x_t), self.circle_radius))
        if ((index_current > self.coordZ1) & (index_current <= self.coordZ2)):
            if ((self.coordX1 == 0) & (self.coordY1 == 0) & (self.coordX2 == 0) & (self.coordY2 == 0)):
                # create a full region mask (except the boundaries)
                bound_width=2 # outer boundary width
                mask[bound_width:dimX-bound_width, bound_width:dimY-bound_width] = 1
            else:
                self.d_step2 = (index_current - self.coordZ1)*self.d_dist2
                t = self.d_step2/self.distance2
                if (self.coordX1 == self.coordX2):
                    x_t = np.int(self.coordX1)
                else:
                    x_t1 = np.round((1.0 - t)*self.coordX1 + t*self.coordX2)
                    x_t = np.int(x_t1[0])
                if(self.coordY1 == self.coordY2):
                    y_t = np.int(self.coordY1)
                else:
                    y_t1 = np.round((1.0 - t)*self.coordY1 + t*self.coordY2)
                    y_t = np.int(y_t1[0])
                mask = np.uint8(circle_level_set(np.shape(data[0]), (y_t, x_t), self.circle_radius))
        return [mask]

    def nInput_datasets(self):
        return 1
    def nOutput_datasets(self):
        return 1
    def get_max_frames(self):
        return 'single'
